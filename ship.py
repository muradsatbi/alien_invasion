import pygame


class Ship():
    """Класс для управления кораблем."""

    def __init__(self, ai_game):
        """Инициализирует корабль и задает его начальную позицию."""
        # Метод __init__ получает два параметра: ссылку self и ссылку на
        # текущий экземпляр класса, в котором он вызывается. Таким образом,
        # класс Ship получает доступ ко всем игровым ресурсам, определенным в
        # Alien Invasion

        self.screen = ai_game.screen
        # Экран присваивается атрибуту Ship self.screen, чтобы обращаться к
        # нему во всех модулях класса

        self.settings = ai_game.settings
        # Создаем атрибут settings, чтобы все параметры численные задавать не
        # в каждом файле, а в одном общем файле и классе.
        # Потом через этот атрибут сделать вызов податрибута ship.speed из
        # Settings()

        self.screen_rect = ai_game.screen.get_rect()
        # Программа обращается к атрибуту rect объекта экрана при помощи
        # get_rect() и присваивает его self.screen_rect. Проще говоря,
        # мы определяем функцию прямоугольника экрана, в которой заложены
        # многие полезные методы такие как center, centerx, centery, top,
        # bottom, left, right

        self.image = pygame.image.load('D:/python projects/alien_invasion/ship.bmp')
        # Загружаем изображение корабля при помощи метода pygame.image.load()

        self.rect = self.image.get_rect()
        # Получаем, скажем так, прямоугольник изображения self.image,
        # применив к нему метод get_rect()

        # Каждый новый корабль появляется у нижнего края экрана.
        self.rect.midbottom = self.screen_rect.midbottom
        # Атрибуты прямоугольника корабля и прямоугольника экрана
        # выравниваются по заданным атрибутам

        # В pygame начало координат (0, 0) находится в левом верхнем углу

        self.x = float(self.rect.x)
        # сохранение вещественной координаты икс середины прямоугольника
        # ихображения корабля, так как сама функция rect принимает только
        # целые значения пикселей. Но так как мы задаем перемещение,
        # то дробное значение пикселей нам важно

        self.moving_right = False
        self.moving_left = False
        # два вспомогательных флажка для функций движения корабля

    def blitme(self):
        """Рисует корабль в текущей позиции."""
        self.screen.blit(self.image, self.rect)
        # Метод, который выводит изображение на экран

    def update(self):
        """Обновляет позицию корабля с учетом флагов передвижения"""
        # Обновляется атрибут x, не rect
        if self.moving_right and self.rect.right < self.screen_rect.right:
            # Во второй части условия проверяется, перешел ли правый край
            # прямоугольника изображения правый край прямоугольника экрана,
            # то же самое и с левыми краями
            self.x += self.settings.ship_speed
            # Действие - перенос прямоугольника корабля на 10 по икс вправо
            # Заменяем действие переноса на 10 пикселей на перенос на то
            # количество, которое указано в классе Ship() в атрибуте ship_speed
        elif self.moving_left and self.rect.left > self.screen_rect.left:
            self.x -= self.settings.ship_speed
            # По итогу совершится перенос на вещественное число,
            # но self.rect.x сохранит только целую часть self.x, но для наших
            # нужд этого достаточно(не понимаю, как, но это снижает
            # скорость), возможно, там работает принцип int, и для наполнения
            # до 1 пикселя нужно в два раза больше времени, то есть
            # достигается 1 пиксель не так: 0, 0.5, 1, а так: 0, 0, 1


        self.rect.x = self.x
        # Обновление атрибута rect на основании self.x

